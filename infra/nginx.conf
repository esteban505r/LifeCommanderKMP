# ===========================
# Logging Configuration
# ===========================
# Custom log format for WebSocket connections
log_format websocket_log '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         'upgrade="$http_upgrade" connection="$connection_upgrade" '
                         'auth_header="$http_authorization"';

# Standard access log format
log_format log_main '$remote_addr - $remote_user [$time_local] "$request" '
                 '$status $body_bytes_sent "$http_referer" '
                 '"$http_user_agent" "$http_x_forwarded_for"';

# ===========================
# WebSocket Connection Header Map
# ===========================
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

# ===========================
# Default servers (raw IP)
# ===========================
server {
    listen 80 default_server;
    return 444;
}

server {
    listen 443 ssl default_server;
    http2 on;

    ssl_certificate     /etc/ssl/cloudflare/cert.pem;
    ssl_certificate_key /etc/ssl/cloudflare/key.pem;

    return 444;
}

# ===========================
# estebanruano.com (Web: Next.js)
# ===========================
server {
    listen 443 ssl;
    http2 on;
    server_name estebanruano.com www.estebanruano.com;

    ssl_certificate     /etc/ssl/cloudflare/cert.pem;
    ssl_certificate_key /etc/ssl/cloudflare/key.pem;

    # DNS resolver for Docker internal DNS
    resolver 127.0.0.11 valid=10s;

    add_header Cache-Control "no-store";
    ssl_protocols TLSv1.2 TLSv1.3;

    proxy_connect_timeout 5s;
    proxy_read_timeout    60s;
    proxy_send_timeout    60s;

    proxy_intercept_errors on;
    error_page 502 503 504 = @upstream_error_web;

    # Block some sensitive files
    location ~* /\.(env|git) {
        return 404;
    }

    # Limit methods
    if ($request_method !~ ^(GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS)$) {
        return 405;
    }

    location / {
        # Use variable to defer DNS resolution until request time
        set $upstream_web "http://nextjs:3000";
        proxy_pass $upstream_web;
        proxy_http_version 1.1;

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade           $http_upgrade;
        proxy_set_header Connection        "upgrade";

        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 1;
    }

    location @upstream_error_web {
        default_type text/html;
        return 503 '<!DOCTYPE html><html><head><title>Service Unavailable</title></head><body><h1>503 Service Unavailable</h1><p>The web service is temporarily unavailable. Please try again later.</p></body></html>';
    }
}

# ===========================
# api.estebanruano.com (Backend API)
# ===========================
server {
    listen 443 ssl;
    http2 on;
    server_name api.estebanruano.com www.api.estebanruano.com;

    ssl_certificate     /etc/ssl/cloudflare/cert.pem;
    ssl_certificate_key /etc/ssl/cloudflare/key.pem;

    # DNS resolver for Docker internal DNS
    resolver 127.0.0.11 valid=10s;

    add_header Cache-Control "no-store";
    ssl_protocols TLSv1.2 TLSv1.3;

    # Logging - log to stdout/stderr for Docker
    access_log /dev/stdout log_main;
    error_log /dev/stderr warn;

    proxy_connect_timeout 5s;
    proxy_read_timeout    60s;
    proxy_send_timeout    60s;

    proxy_intercept_errors on;
    error_page 502 503 504 = @upstream_error_api;

    # Block some sensitive files
    location ~* /\.(env|git) {
        return 404;
    }

    # WebSocket endpoint for timer notifications (must be before method check)
    location /api/v1/timers/notifications {
        # Use variable to defer DNS resolution until request time
        set $upstream_api "http://oter:8080";
        
        # Enhanced logging for WebSocket connections
        access_log /dev/stdout websocket_log;
        
        proxy_pass $upstream_api;
        proxy_http_version 1.1;

        # WebSocket upgrade headers - preserve original headers
        proxy_set_header Upgrade           $http_upgrade;
        proxy_set_header Connection        $connection_upgrade;

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Forward Authorization header (required for authenticated WebSocket)
        proxy_set_header Authorization    $http_authorization;
        
        # Preserve original request headers that might be needed
        proxy_set_header Origin            $http_origin;

        # WebSocket timeouts
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
        proxy_connect_timeout 60s;
        
        # Don't buffer WebSocket connections
        proxy_buffering off;
        proxy_cache_bypass $http_upgrade;
    }

    # Limit methods (after WebSocket location)
    if ($request_method !~ ^(GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS)$) {
        return 405;
    }

    location / {
        # Use variable to defer DNS resolution until request time
        set $upstream_api "http://oter:8080";
        proxy_pass $upstream_api;
        proxy_http_version 1.1;

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Forward Authorization header for authenticated requests
        proxy_set_header Authorization    $http_authorization;
    }

    location @upstream_error_api {
        default_type text/html;
        return 503 '<!DOCTYPE html><html><head><title>Service Unavailable</title></head><body><h1>503 Service Unavailable</h1><p>The API service is temporarily unavailable. Please try again later.</p></body></html>';
    }
}

# ===========================
# HTTP â†’ HTTPS redirect (all)
# ===========================
server {
    listen 80;
    server_name
        estebanruano.com www.estebanruano.com
        api.estebanruano.com www.api.estebanruano.com;

    # For future ACME http-01 if you want real certs instead of origin cert
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}
